<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../basic-sequence/basic-sequence.html">

<!--
TODO: Make component focusable, don't wire up document handler (by default).
outline: -webkit-focus-ring-color auto 5px;
Use icons from core-icon
-->

<polymer-element name="basic-sequence-navigator" attributes="selected">

<template>
  <style>
  :host {
    display: block;
  }

  #sequenceNavigationContainer {
    align-items: center;
    display: flex;
  }

  .navigationButton {
    background: white;
    border: 1px solid transparent;
    box-sizing: border-box;
    color: #444;
    font-family: monospace; /* Less than/greater than tend to look better */
    font-size: 1.5em;
    font-weight: bold;
    height: 1.5em;
    margin: 0;
  }
  .navigationButton:hover:not(:disabled) {
    background: #ddd;
    color: black;
  }
  .navigationButton:disabled {
    color: #aaa;
  }
  </style>
  <div id="sequenceNavigationContainer">
    <button class="navigationButton" on-click="{{previous}}" disabled?="{{!canGoPrevious}}">&lt;</button>
    <basic-sequence id="sequence" selected="{{selected}}" canGoNext="{{canGoNext}}" canGoPrevious="{{canGoPrevious}}">
      <content></content>
    </basic-sequence>
    <button class="navigationButton" on-click="{{next}}" disabled?="{{!canGoNext}}">&gt;</button>
  </div>
</template>

<script>
Polymer( "basic-sequence-navigator", {

  /**
   * Move to the next child in the sequence of children.
   * If the last child is already the active one being shown, this has no effect.
   *
   * @method next
   */
  next: function() {
    this.$.sequence.next();
  },

  ready: function() {
    this.super();
    this.$.sequence.addEventListener( "core-select", function( event ) {
      if ( event.detail.isSelected ) {
        this._slideToChild( event.detail.item );
      }
    }.bind( this ));
    document.addEventListener( "keydown", function( event ) {
      var handled;
      switch ( event.which ) { 
        case 37: // Left
          this.previous();
          handled = true;
          break;

        case 39: // Right
          this.next();
          handled = true;
          break;
      }
      if ( handled ) {
        event.stopPropagation();
      }
    }.bind( this ));
  },

  /**
   * Move to the previous child in the sequence of children.
   * If the first child is already the active one being shown, this has no effect.
   *
   * @method previous
   */
  previous: function() {
    this.$.sequence.previous();
  },

  _slideToChild: function( newItem ) {
    var newIndex = Array.prototype.indexOf.call( this.$.sequence.items, newItem );
    if ( newIndex < 0 ) {
      console.log( "couldn't find item" );
      return;
    }
    var oldIndex = this._previousSelectionIndex;
    this._previousSelectionIndex = newIndex;
    if ( oldIndex == null ) {
      // First time selecting, no slide necessary.
      return;
    }
    if ( newIndex === oldIndex ) {
      // We shouldn't have received an event in this case, but just in case...
      return;
    }
    var direction = ( newIndex > oldIndex );
    var arrow = direction ? " -> " : " <- ";
    console.log( oldIndex + arrow + newIndex );
  },

  _previousSelectionIndex: null
  
});
</script>

</polymer-element>
